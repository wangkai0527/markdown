[TOC]



# 强制类型转换
C++中强制类型转换操作符有四种:
static_cast
const_cast
reinterpert_cast
dynamic_cast


## static_cast
static_cast是一个强制类型转换操作符。强制类型转换，也称为显式转换。
 

编译器隐式执行的任何类型转换都可以由static_cast来完成，比如int与float、double与char、enum与int之间的转换等。
```C++
    double a = 1.999;
    int b = static_cast<double>(a); //相当于a = b ;
```

当编译器隐式执行类型转换时，大多数的编译器都会给出一个警告：

    e:\vs 2010 projects\static_cast\static_cast\static_cast.cpp(11): warning C4244: “初始化”: 从“double”转换到“int”，可能丢失数据

使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的，也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽。

把精度大的类型转换为精度小的类型，static_cast使用位截断进行处理。

使用static_cast可以找回存放在void*指针中的值。
```C++
    double a = 1.999;
    void * vptr = & a;
    double * dptr = static_cast<double*>(vptr);
    cout<<*dptr<<endl;//输出1.999
```

static_cast也可以用在于基类与派生类指针或引用类型之间的转换。然而它不做运行时的检查，不如dynamic_cast安全。static_cast仅仅是依靠类型转换语句中提供的信息来进行转换，而dynamic_cast则会遍历整个类继承体系进行类型检查,因此dynamic_cast在执行效率上比static_cast要差一些。现在我们有父类与其派生类如下：

```C++
class ANIMAL
{
public:
    ANIMAL():_type("ANIMAL"){};
    virtual void OutPutname(){cout<<"ANIMAL";};
private:
    string _type ;
};
class DOG:public ANIMAL
{
public:
    DOG():_name("大黄"),_type("DOG"){};
    void OutPutname(){cout<<_name;};
    void OutPuttype(){cout<<_type;};
private:
    string _name ;
    string _type ;
};
```

此时我们进行派生类与基类类型指针的转换：注意从下向上的转换是安全的，从上向下的转换不一定安全。

```C++
int main()
{
    //基类指针转为派生类指针,且该基类指针指向基类对象。
    ANIMAL * ani1 = new ANIMAL ;
    DOG * dog1 = static_cast<DOG*>(ani1);
    //dog1->OutPuttype();//错误，在ANIMAL类型指针不能调用方法OutPutType（）；在运行时出现错误。

    //基类指针转为派生类指针，且该基类指针指向派生类对象
    ANIMAL * ani3 = new DOG;
    DOG* dog3 = static_cast<DOG*>(ani3);
    dog3->OutPutname(); //正确

    //子类指针转为派生类指针
    DOG *dog2= new DOG;
    ANIMAL *ani2 = static_cast<DOG*>(dog2);
    ani2->OutPutname(); //正确，结果输出为大黄

    //
    system("pause");

}
```

static_cast可以把任何类型的表达式转换成void类型。
static_cast把任何类型的表达式转换成void类型。
另外，与const_cast相比，static_cast不能把换掉变量的const属性，也包括volitale或者__unaligned属性。


在功能上基本上与C风格的类型转换一样强大，含义也一样。它有功能上的限制。例如，你不能用static_cast像用C风格转换一样把struct转换成int类型或者把double类型转换成指针类型。另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换符const_cast有这样的功能。 
可以静态决议出类型的转换可能性，即使是在继承体系中，即使包括了多重继承和虚继承，只要可以进行静态决议就可以转换成功 


允许执行任意的隐式转换和相反转换动作（即使它是不允许隐式的）,例如：应用到类 的指针上, 意思是说它允许子类类型的指针转换为父类类型的指针(这是一个有效的隐式转换), 同 时, 也能够执行相敏感词作: 转换父类为它的子类 
```C++
class Base {}; 
class Derive:public Base{}; 
Base* a = new Base; 
Derive *b = static_cast(a); 
```




1）基本类型之间的转换，但不能用于基本类型指针之间的类型转换（void指针和基本类型指针之间可以）
```C++
 double d=0;
 int i=static_cast<int>(d);
```

2）用于有继承关系的子类与父类之间的指针或引用的转换
3）空类型指针转换为任意基本类型的指针
第三条是这里面很容易出错，因为有可能出现未知的转换结果，要保证转换的正确性就必须保证转换后所得的类型就是指针原先的类型。
先看一个转换正确的例子
```C++
int i=0;
void *vp=&i;
int *p=static_cast<int*>(vp);
*p=3;
cout<<i<<endl;
```

输出结果是 3
我们分析一下： i的初始类型为int 然后我们将i的地址转换为void*，然后void指针vp转换为int指针，此时int型指针 p和vp指向的i的原始类型int一致，所以转换结果正确。



接下来再看几个错误的例子
例1：
```C++
int  i=3;
void *vp=&i;
char *p=static_cast<char*>(vp);
*p=4
cout<<i<<endl;
```

输出结果是 4
我们分析一下：初看来我们的结果是正确的，但是这里实际是有错误的，或者说是不安全的转换。
考虑如下代码：
```C++
int  i=256;
void *vp=&i;
char *p=static_cast<char*>(vp);
*p=4；
cout<<i<<endl;
```

输出结果是 260

这是为什么呢，让我们来分析一下。上面的两个例子都是错误的，原因就在于，最后转换的类型与数据的初始类型是不一样的，但是为什么输出结果一个正确，一个却是错误的呢。原因就在于不同的数据类型占用的字节数是不一样的，在我的机器里char是一个字节也就是8位，int是4字节，也就是32位，在第一个例子里3的二进制是0...0 0000 0011，那么在转换为char指针时实际指向低8位数据空间，也就是00000011所在位置，然后经过*p=4以后，变为00000100，因此数据i的二进制就变成了0...0 0000 0100  ，也就是4，虽然结果没错，但是是不安全的，而第二个例子就体现了不安全。
同样对第二个例子进行分析。256的二进制是0000 0000 0000 0000 0000 0001 0000 0000，转换后char指针仍然指向低8位所在的数据空间，也就是0000 0000所在位置，然后经过*p=4以后，变为00000100，因此数据i的二进制就变成了0000 0000 0000 0000 0000 0001 0000 0100，转换成十进制就是260。

接下来再看一个例子
```C++
int  i=4294967294;
void *vp=&i;
double *p=static_cast<double*>(vp);
*p=4；
cout<<i<<endl;
```

输出结果是0

这里出现错误同样是和上面的两个例子一样，之所以结果是0，我个人的理解是由于浮点型表示形式不同所导致的。










用法：static_cast < type-id > ( expression )

一般来说，编译器隐式执行的任何类型转换都可以由static_cast显式完成。static_cast可以用来将枚举类型转换成整型，或者整型转换成浮点型。也可以用来将指向父类的指针转换成指向子类的指针。做这些转换前，你必须确定要转换的数据确实是目标类型的数据，因为static_cast不做运行时的类型检查以保证转换的安全性。也因此，static_cast不如dynamic_cast安全。对含有二义性的指针，dynamic_cast会转换失败，而static_cast却直接且粗暴地进行转换，这是非常危险的。

还有要注意的是，他不能转换掉expression的const、volatile、或者__unaligned属性，同样也不能用来去掉static属性。

C++中的static_cast执行非多态的转换，用于代替C中通常的转换操作。对于我们的static_cast转换符，他不仅可以应用到指针和引用上，而且还可以应用到基础数据结构和对象上。

（1）用于基本的数据类型转换（char，int），及指针之间的转换

```C++
#include <iostream>
using namespace std;
 
int main()
{
	char a = 'c';
	int b = static_cast<int>(a);
	char c = static_cast<char>(b);
	cout<<"a= "<<a<<endl;
	cout<<"b= "<<b<<endl;
	cout<<"c= "<<c<<endl;
 
	char* pa = &a;
	int *pb = (int*)pa;
	//int *pb = static_cast<int*>(pa);   //error
	//pa = static_cast<char*>(pb);   //error
	char *pc = (char*)pb;
	//char *pc = static_cast<char*>(pb);  //error
	cout<<"pa= "<<pa<<endl;
	cout<<"pb= "<<pb<<endl;
	cout<<"pc= "<<pc<<endl;
 
	void *pd = static_cast<void*>(pa);
	int *pe = static_cast<int*>(pd);
	char *pf = static_cast<char*>(pd);
	cout<<"pd= "<<pd<<endl;
	cout<<"pe= "<<pe<<endl;
	cout<<"pf= "<<pf<<endl;
 
	system("pause");
	return 0;
}
```

但是有些情况需要注意的，不然很容易出错，例如：
```C++
#include <iostream>
using namespace std;
 
int main()
{
	int a = 2;
	int b = 3;
	double c,d;
	c = static_cast<double>(a)/b;
	d = static_cast<double>(a/b); //错误
	cout<<"c= "<<c<<endl;
	cout<<"d= "<<d<<endl;
	system("pause");
	return 0;
}
```

（2）类层次中基类与子类成员函数指针的转换
```C++
class A
{
public:
    void set(){}
};
class B:public A
{
public:
    void set(){}
};
typedef void (A::*PS_MFunc)();      　　//指向类A的成员函数指针
 
PS_MFunc func = &A::set;
func = static_cast<PS_MFunc>(&B::set); //基类指向子类成员函数指针，必须进行转换
```


（3）类层次结构中基类与子类指针或引用之间的转换

 上行转换：子类指针或引用转换成基类表示——安全

　　下行转换：基类指针或引用转换成子类表示——危险（没有动态类型检查）
```C++
class A
{
};
class B:public A
{
};
class C:public A
{
};
class D
{
};
A objA;
B objB;
A* pObjA = new A();
B* pObjB = new B();
C* pObjC = new C();
D* pObjD = new D();
 
objA = static_cast<A&>(objB);     //转换为基类引用    
objA = static_cast<A>(objB);
objB = static_cast<B>(objA);      //error 不能进行转换  
 
pObjA = pObjB;                    //right 基类指针指向子类对象
//objB = objA;                      //error 子类指针指向基类对象
pObjA = static_cast<A*>(pObjB);   //right 基类指针指向子类
pObjB = static_cast<B*>(pObjA);   //强制转换 OK 基类到子类
//pObjC = static_cast<C*>(pObjB);   //error 继承于统一类的派生指针之间转换 
//pObjD = static_cast<D*>(pObjC);   //error 两个无关联之间转换</span>
```
最后总结一下：

static_cast常用来进行基本类型直接的转换，如char与int、int与float、enum与int之间；

static_cast也可以转换用户自定义类型，但目标类型必须含有相应的构造函数；

static_cast还可以转换对象的指针类型，但它不进行运行时类型检查，所以是不安全的；

static_cast甚至可以把任何表达式都转换成void类型；

satic_cast不能移除变量的const属性，请参考const_cast操作符；

static_cast进行的是简单粗暴的转换，所以其正确性完全由程序员自己保证。







## const_cast
 这个转换类型操纵传递对象的const属性，或者是设置或者是移除,例如： 
```C++
class C{}; 
const C* a = new C; 
C *b = const_cast(a);
```
用于类型转换掉表达式的const或volatile属性。通过使用const_cast，你向人们和编译器强调你通过类型转换想做的只是改变一些东西的constness或者volatieness属性。这个含义被编译器所约束。如果你试图使用const_cast来完成修改constness或者volatileness属性之外的事情，你的类型转换将被拒绝。 




## reinterpert_cast
使用这个操作符的类型转换，其转换结果几乎都是执行期定义。因此，使用reinterpret_cast的代码很难移植。reinterpret_casts的最普通的用途就是在函数指针类型之间进行转换。

转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型,反之亦 然. 这个操作符能够在非相关的类型之间转换. 操作结果只是简单的从一个指针到别的指针的值的 二进制拷贝. 在类型之间指向的内容不做任何类型的检查和转换? 
```C++
class A{}; 
class B{}; 
A* a = new A;

B* b = reinterpret_cast (a); 
```


## dynamic_cast

它被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）。 

只用于对象的指针和引用. 当用于多态类型时，它允许任意的隐式类型转换以及相 反过程. 不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程）,dynamic_cast 会检查操作是否有效. 也就是说, 它会检查转换是否会返回一个被请求的有效的完整对象。检测在 运行时进行. 如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL. 对于引用 类型，会抛出bad_cast异常 







# 避免隐式类型转换

## explicit关键字
1. 指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化.
2. explicit 指定符可以与常量表达式一同使用. 函数若且唯若该常量表达式求值为 true 才为显式. (C++20起)

注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中


C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色：
1 是个构造
2 是个默认且隐含的类型转换操作符。
所以， 有时候在对象刚刚定义时, 即使你使用的是赋值操作符` = `, 也是会调用构造函数, 而不是重载的`operator=`运算符。例如我们写下如` AAA = XXX`， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。


```C++
#include <iostream>
using namespace std;

class Point {
public:
    int x, y;
    explicit Point(int x = 0, int y = 0)
        : x(x), y(y) {}
};

void displayPoint(const Point& p) 
{
    cout << "(" << p.x << "," 
         << p.y << ")" << endl;
}

int main()
{
	
	// displayPoint(1);		//加了explicit之后会报error
    // Point p = 1;			//加了explicit之后会报error

    displayPoint(Point(1));
    Point p(1);
}
```







