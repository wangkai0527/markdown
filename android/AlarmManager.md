[TOC]

# AlarmManager


Android中的定时任务一般有两种实现方式，
一种是使用 Java API 里提供的 Timer 类，一种是使用 Android 的 Alarm 机制。
这两种方式在多数情况下都能实现类似的效果，但 Timer 有一个明显的短板，它并不适用于那些需要长期在后台运行的定时任务。
我们都知道，为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android 手机就会在长时间不操作的情况下自动让 CPU 进入到睡眠状态，这就有可能导致 Timer 中的定时任务无法正常运行。
而 Alarm 则具有唤醒 CPU 的功能，它可以在需要执行定时任务的时候唤醒CPU。需要注意，这里唤醒 CPU 和唤醒屏幕完全不是一个概念，千万不要混淆。



在 API > 19 的手机上运行就会发现问题。
例如我们设置1分钟后执行，结果却是2分钟后才执行。
原因是 Google 对系统耗电性方面进行了优化。
系统会自动检测目前有多少 Alarm 任务存在，然后将触发时间相近的几个任务放在一起执行，这就可以大幅度减少 CPU 被唤醒的次数，从而有效延长电池的使用时间。 
当然，如果你要求的 Alarm 任务执行时间必须准确无误，Android 仍然提供了解决方案。
使用 AlarmManager 的 setExact()方法来代替set()方法，就基本上可以保证任务能够准时执行了。


虽然Android的每个系统版本都在手机电量方面努力进行优化，不过一直没能解决后台服务泛滥、手机电量消耗过快的问题。
于是在Android 6.0系统中，谷歌加入了一个全新的Doze模式，从而可以极大幅度地延长电池的使用寿命。 
到底什么是Doze模式。当用户的设备是Android 6.0或以上系统时，如果该设备未插接电源，处于静止状态( Android 7.0中删除了这条件)， 且屏幕关闭了一段时间之后，就会进人到Doze模式。
在Doze模式下，系统会对CPU、网络、Alarm等活动进行限制，从而延长了电池的使用寿命。 
当然，系统并不会一直处于 Doze模式，而是会间歇性地退出Doze模式一小段时间，在这段时间中，应用就可以去完成它们的同步操作、Alarm任务， 等等。 
接下来我们具体看- 看在Doze模式下有哪些功能会受到限制吧。

+ 网络访问被禁止
+ 系统忽略唤醒CPU或者屏幕操作
+ 系统不再执行WIFI扫描
+ 系统不再执行同步服务
+ Alarm任务将会在下次退出Doze模式的时候执行

注意其中的最后一条， 也就是说，在Doze模式下，我们的Alarm任务将会变得不准时。
当然，这在大多数情况下都是合理的，因为只有当用户长时间不使用手机的时候才会进入Doze模式，通常在这种情况下对Alarm任务的准时性要求并没有那么高。 
不过，如果你真的有非常特殊的需求，要求Alarm任务即使在Doze模式下也必须正常执行，Android还是提供了解决方案。
调用AlarmManager的setAndAllowWhileIdle()或setExact-AndAllowhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别是一样的。









