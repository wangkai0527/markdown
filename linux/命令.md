[TOC]

# 命令




## 系统版本信息

`cat /etc/issue`

    Ubuntu 20.04 LTS \n \l

`uname -a`，Linux内核版本号 + 系统是多少位的(X86_64代表系统是64位的，aarch64代表系统是ARM架构的)

    Linux ZJ-DI-1499F 5.10.16.3-microsoft-standard-WSL2 #1 SMP Fri Apr 2 22:23:49 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

`cat /proc/version`，Linux内核版本号 + GCC编译器版本号

    Linux version 5.10.16.3-microsoft-standard-WSL2 (oe-user@oe-host) (x86_64-msft-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220) #1 SMP Fri Apr 2 22:23:49 UTC 2021

`cat /etc/lsb-release`

    DISTRIB_ID=Ubuntu
    DISTRIB_RELEASE=20.04
    DISTRIB_CODENAME=focal
    DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"

`lsb_release -a`

    No LSB modules are available.
    Distributor ID: Ubuntu                  //类别
    Description:    Ubuntu 20.04 LTS        //版本说明，稳定版本Long Term Support
    Release:        20.04                   //版本号
    Codename:       focal                   //代号



## cd
cd - 的作用是可以回到前一个目录。这样就可以在两个目录之间切换。
因为 - 在此处等同于 `$OLDPWD` 变量，`$OLDPWD` 变量就是bash所记录的前一个目录。

    wk@ZJ-DI-1499F:/usr/bin$ cd /lib/x86_64-linux-gnu/
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ echo $OLDPWD
    /usr/bin
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ cd -
    /usr/bin
    wk@ZJ-DI-1499F:/usr/bin$ echo $OLDPWD
    /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/usr/bin$ cd -
    /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ echo $OLDPWD
    /usr/bin


## pushd
切换到作为参数的目录，并把原目录和当前目录压入到一个虚拟的堆栈中如果不指定参数，则会回到前一个目录，并把堆栈中最近的两个目录作交换。
用 pushd +n 可以在多个目录之间切换
说明: n 是一个数字,有此参数时，是切换到堆栈中的第n个目录,并把此目录以堆栈循环的方式推到堆栈的顶部。
最近压入堆栈的目录位于最上面。
在最近的两个目录之间切换：用pushd不加参数即可

## popd
弹出堆栈中最近的目录。
popd 不加参数时，把堆栈顶端的目录从堆栈中删除，并切换于位于新的顶端的目录。
popd 加参数 +n时，n 是堆栈中的第n个目录，表示把堆栈中第n个目录从堆栈中删除。

## dirs
列出当前堆栈中保存的目录列表。
-v 可以在目录前加上编号。
-c 可以清空目录堆栈
说明:  位于堆栈顶部的目录是当前目录，它不能被pop出去的。


    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ dirs -v
    0  /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ pushd /usr/bin
    /usr/bin /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/usr/bin$
    wk@ZJ-DI-1499F:/usr/bin$ dirs -v
    0  /usr/bin
    1  /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/usr/bin$ pushd /usr/local/include/
    /usr/local/include /usr/bin /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/usr/local/include$ dirs -v
    0  /usr/local/include
    1  /usr/bin
    2  /lib/x86_64-linux-gnu
    wk@ZJ-DI-1499F:/usr/local/include$ pushd +2
    /lib/x86_64-linux-gnu /usr/local/include /usr/bin
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ dirs -v
    0  /lib/x86_64-linux-gnu
    1  /usr/local/include
    2  /usr/bin
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ pushd
    /usr/local/include /lib/x86_64-linux-gnu /usr/bin
    wk@ZJ-DI-1499F:/usr/local/include$ dirs -v
    0  /usr/local/include
    1  /lib/x86_64-linux-gnu
    2  /usr/bin
    wk@ZJ-DI-1499F:/usr/local/include$ popd
    /lib/x86_64-linux-gnu /usr/bin
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ dirs -v
    0  /lib/x86_64-linux-gnu
    1  /usr/bin
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ dirs -c
    wk@ZJ-DI-1499F:/lib/x86_64-linux-gnu$ dirs -v
    0  /lib/x86_64-linux-gnu



## source
在当前bash环境下读取并执行FileName中的命令。
source命令（从 C Shell 而来）是bash shell的内置命令. 点命令，就是一个点符号，是source的另一名称。
这两个命令都以一个脚本为参数，该脚本将在当前shell的环境执行，即不会启动一个新的子shell。所有在脚本中设置的变量都将成为当前Shell的一部分。

source filename 与 sh filename 及./filename执行脚本的区别
当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有”.”是用来表示当前目录的。
sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，__*除非使用export*__。
source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。

假如用`./a.sh`执行该脚本，执行完毕后，在当前shell环境中运行 `echo $KKK`，发现没有值，但是用 `source a.sh` 来执行 ，然后再 `echo $KKK`，就会发现 打印 111 。
因为调用`./a.sh`来执行shell是在一个子shell里运行的，所以执行后，结构并没有反应到父shell里，但是source不同他就是在本shell中执行的，所以能够看到结果。



## netstat
端口占用情况查看

    sudo apt install net-tools
    netstat -anp|grep 5037



## time
linux下time命令可以获取到一个程序的执行时间，包括程序的实际运行时间(real time)，以及程序运行在用户态的时间(user time)和内核态的时间(sys time)。
它的使用方法和前面讲过的strace类似，在待执行的命令前加上time即可。

【命令】time — 执行命令并计时
【格式】time [-p] command [arguments...]
【说明】
执行命令行"command [arguments...]"，命令行执行结束时在标准输出中打印执行该命令行的时间统计结果，其统计结果包含以下数据：
1)实际时间(real time): 从command命令行开始执行到运行终止的消逝时间；
2)用户CPU时间(user CPU time): 命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；
3)系统CPU时间(system CPU time): 命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和。
其中，用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。



来看一个例子程序test.c
```C
#include <stdio.h>
int main()
{
FILE *fp = fopen("/tmp/testfile","w");
int i=0;
for(i=0;i<3;++i)
{
fprintf(fp,"%d\n",i);
}
fclose(fp);
return 0;
}
```

编译后用time命令来统计它的执行时间：

    [leconte@localhost test]$ time ./test
    real    0m0.020s
    user    0m0.000s
    sys     0m0.018s

结果表明，程序实际运行时间0.020s，用户态运行时间接近0s，内核态运行时间0.018s。这是因为我们主要操作是使用文件相关的系统调用，程序大部分时间工作在内核态。

需要注意的是，real并不等于user+sys的总和。real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的。

例如我在上述程序中加上sleep(1)：
```C
for(i=0;i<3;++i)
{
sleep(1);
fprintf(fp,"%d\n",i);
}
```

用time统计结果如下：

    [leconte@localhost test]$ time ./test
    real    0m3.025s
    user    0m0.000s
    sys     0m0.019s

由于执行了三次 sleep(1)，real的时间比刚才多了3s，这3s内程序并没有占用CPU，因此user+sys并没有变化


另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。

例1：

    1. # time date
    2. Sun Mar 26 22:45:34 GMT-8 2006
    3. 
    4. real    0m0.136s
    5. user    0m0.010s
    6. sys     0m0.070s
    7. #

在例1中，执行命令"time date"(见第1行)。系统先执行命令"date"，第2行为命令"date"的执行结果。第3-6行为执行命令"date"的时间统计结果，其中第4行"real"为实际时间，第5行"user"为用户CPU时间，第6行"sys"为系统CPU时间。以上三种时间的显示格式均为MMmNN[.FFF]s。

在例1中，CPU时间 = 用户CPU时间 + 系统CPU时间 = 0m0.010s + 0m0.070s = 0m0.080s，实际时间大于CPU时间，说明在date命令运行的同时，还有其它任务在运行。


【参数说明】
-p 以POSIX缺省的时间格式打印时间统计结果，单位为秒。详细的输出格式见例2。
例2：

    1. # time -p date
    2. Wed Mar 27 00:33:11 GMT-8 2006
    3. real 0.11
    4. user 0.00
    5. sys 0.02
    6. #

在例2中，同样执行命令"time date"(见第1行)。系统先执行命令 "date"，第2行为该命令的执行结果。第3-5行为执行命令"date"的时间统计结果。注意本例的时间格式与例1中的时间格式差别，使用-p 参数后的时间显示格式为NN.FF，其单位为秒。

【相关环境变量说明】
TIMEFORMAT 自定义输出的时间格式。
我们也可以通过环境变量TIMEFORMAT来自定义输出的时间格式[1]。格式中使用和标准C中的函数printf一致的转义符，以及使用以下的转义序列来指定输出的时间格式：
  %[prec][l][RUS]
其中，选项prec为指定时间精度，即小数点后面的位数；选项l表示使用分秒(具体格式为：MMmNN[.FFF]s)的格式；最后一个字符表示时间的类型，其中R表示实际时间，U表示用户CPU时间，S表示系统CPU 时间，它们的单位均为秒。
time命令缺省输出的时间格式同 TIMEFORMAT=$'/nreal/t%3lR/nuser/t%3lU/nsys/t%3lS'。

使用-p参数的time命令输出的时间格式同 TIMEFORMAT=$'real %2R/nuser %2U/nsys %2S'。

例3：

    1. # export TIMEFORMAT=$'real %2R/nuser %2U/nsys %2S'
    2. # time date
    3. Wed Mar 27 00:52:03 GMT-8 2006
    4. real 0.04
    5. user 0.00
    6. sys 0.01
    7. #

比较例2和例3显示结果，很容易发现例3虽然没有使用参数-p，但其输出的结果和例2一模一样。

当然，我们也可以修改为任何自己喜欢的时间格式。

例4：

    1. # export TIMEFORMAT=$'/nHello, ThinkerABC!/nreal time :       %lR/nuser CUP time :   %lU/nsystem CPU time : %lS'
    2. # time date
    3. Wed Mar 27 01:09:26 GMT-8 2006
    4.
    5. Hello, ThinkerABC!
    6. real time :       0m0.016s
    7. user CUP time :   0m0.006s
    8. system CPU time : 0m0.008s
    9. #

例4的第4-8行正是我们自定义的输出格式。

从以上介绍了三种指定时间格式的方法，即缺省的时间格式、使用参数-p的POSIX缺省的时间格式和设定环境变量TIMEFORMAT自定义的时间格式，Linux系统使用的先后顺序如下：
1.参数-p的POSIX缺省时间格式；
2.环境变量TIMEFORMAT自定义的时间格式；
3.缺省的时间格式。


【退出状态说明】
如果能执行command命令，则返回该命令的退出状态，否则返回如下的退出状态值：
127 命令未找到
126 命令找到，但不能执行
1-125 其它错误




## whereis
查看文件安装路径
`whereis cmake`


## which
查看运行文件所在路径
`which cmake`


## find
`find /usr/bin/ -name cmake`
`find ./ -name "pbisp" | xargs md5sum`



## locate
locate命令其实是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息。
Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。
为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。

`sudo apt install mlocate`

用法: locate [OPTION]... [PATTERN]...
在mlocate数据库中搜索条目.
 -A, --all   只显示匹配所有模式的条目
 -b, --basename     匹配唯一的路径名称的基本文件名
 -c, --count      只显示找到条目的号码
 -d, --database DBPATH 用 DBPATH 替代默认的数据库(/var/lib/mlocate/mlocate.db)
 -e, --existing     只显示当前存在的文件条目
 -L, --follow      当文件存在时跟随蔓延的符号链接 (默认)
 -h, --help       显示本帮助
 -i, --ignore-case   匹配模式时忽略大小写区别
 -l, --limit, -n LIMIT 限制为 LIMIT项目的输出 (或 计数) 
 -m, --mmap       忽略向后兼容性
 -P, --nofollow, -H   当检查文件时不跟随蔓延的符号链接
 -0, --null       输出时以 NUL 分隔项目
 -S, --statistics    不搜索项目,显示有关每个已用数据库的统计信息
 -q, --quiet      不报告关于读取数据库的错误消息
 -r, --regexp REGEXP  搜索基本正则表达式 REGEXP 来代替模式
   --regex      模式是扩展正则表达式
 -s, --stdio      忽略向后兼容性
 -V, --version     显示版本信息
 -w, --wholename    匹配完整路径名 (默认)


查找包含某个字符串的相关文件
`locate ifconfig `

搜索目录下所有以 sh开头的文件
`locate /bin/sh`

指定显示数量
`locate -n 3 ifconfig `

匹配模式时忽略大小写区别
`locate -i -n 3 ifconfig `

当需要查找符合特定规则的信息时，可以使用 -r 选项匹配相应的正则表达式。
查找以/var/lib/rpm开头的文件
`locate -r ^/var/lib/rpm`
查找etc.conf结尾的文件
`locate -r etc.conf$`

查看统计信息
`locate -S`

查看passwd统计数量
`locate -c passwd`




## ps


## top
实时显示当前进程状态，最活跃的进程显示在最顶部。



## ulimit
ulimit为shell内建指令，可用来控制shell执行程序的资源。

https://cloud.tencent.com/developer/article/1982394



## awk

https://www.runoob.com/linux/linux-comm-awk.html

http://c.biancheng.net/view/4082.html
















## 好玩的命令

https://www.cnblogs.com/yhyjy/archive/2013/06/09/3127971.html









