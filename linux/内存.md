[TOC]


# 内存



## free
用于显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存，共享内存将被忽略。

free的选项有
-h 以人类易读的友好方式显示内存使用情况
-o	不显示缓冲区调节列。
-s 秒数 表示隔几秒更新
-t	显示内存总和列。
-c 次数 表示总的更新次数，如果不加则一直更新
-b -k -m -g 分别表示以byte,kb,mb,gb为单位显示

所以要以mb为单位每秒更新一次内存使用情况的指令就是：

    $ free -m -s 1

    $ free -h
                  total        used        free      shared  buff/cache   available
    Mem:           12Gi        99Mi        12Gi       0.0Ki        84Mi        12Gi
    Swap:         4.0Gi          0B       4.0Gi


下面先解释一下输出的内容：
Mem 行(第二行)是内存的使用情况。
Swap 行(第三行)是交换空间的使用情况。
total 列显示系统总的可用物理内存和交换空间大小。
used 列显示已经被使用的物理内存和交换空间。
free 列显示还有多少物理内存和交换空间可用使用。
shared 列显示被共享使用的物理内存大小。
buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。
available 列显示还可以被应用程序使用的物理内存大小。


### buff/cache
先来提一个问题： buffer 和 cache 应该是两种类型的内存，但是 free 命令为什么会把它们放在一起呢？要回答这个问题需要我们做些准备工作。让我们先来搞清楚 buffer 与 cache 的含义。

buffer 在操作系统中指 buffer cache， 中文一般翻译为 "缓冲区"。要理解缓冲区，必须明确另外两个概念："扇区" 和 "块"。扇区是设备的最小寻址单元，也叫 "硬扇区" 或 "设备块"。块是操作系统中文件系统的最小寻址单元，也叫 "文件块" 或 "I/O 块"。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示。



注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。

cache 在操作系统中指 page cache，中文一般翻译为 "页高速缓存"。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写。
页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。
页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。

到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。
那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。

### free 与 available
在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？
free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available  = free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。

### 交换空间(swap space)
swap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。

现在的机器一般都不太缺内存，如果系统默认还是使用了 swap 是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做 swappiness 的参数，用于配置需要将内存中不常用的数据移到 swap 中去的紧迫程度。这个参数的取值范围是 0～100，0 告诉内核尽可能的不要将内存数据移到 swap 中，也即只有在迫不得已的情况下才这么做，而 100 告诉内核只要有可能，尽量的将内存中不常访问的数据移到 swap 中。在 ubuntu 系统中，swappiness 的默认值是 60。如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness：

vm.swappiness=10
如果系统的内存不足，则需要根据物理内存的大小来设置交换空间的大小。具体的策略网上有很丰富的资料，这里笔者不再赘述。

### /proc/meminfo 文件
其实 free 命令中的信息都来自于 /proc/meminfo 文件。/proc/meminfo 文件包含了更多更原始的信息，只是看起来不太直观：
`$ cat /proc/meminfo`






## malloc
malloc的实现与物理内存自然是无关的，内核为每个进程维护一张页表，页表存储进程空间内每页的虚拟地址，页表项中有的虚拟内存页对应着某个物理内存页面，也有的虚拟内存页没有实际的物理页面对应。
无论malloc通过sbrk还是mmap实现，分配到的内存只是虚拟内存，而且只是虚拟内存的页号，代表这块空间进程可以用，实际上还没有分配到实际的物理页面。
等你的进程访问到这个新分配的内存空间的时候，如果其还没有对应的物理页面分配，就会产生缺页中断，内核这个时候会给进程分配实际的物理页面，以与这个未被映射的虚拟页面对应起来，然后程序就可以欢快的继续往下跑了。


malloc是一个库函数，不同的操作系统上具体实现细节是不同的，以下就以linux条件下进行分析：
linux采用的是glibc中堆内存管理ptmalloc实现，虚拟内存的布局规定了malloc申请位置以及大小，
malloc一次性能申请小内存（小于128KB），分配的是在堆区（heap），用sbrk()进行对齐生长，(内存池中)
而malloc一次性申请大内存（大于128KB时）分配到的是在映射区，而不是在堆区，采用的mmap()系统调用进行映射。
当然虚拟地址只是规定了一种最理想的状态，实际分配还是要考虑到物理内存加交换内存总量的限制，因为每次分配，特别是大内存分配采用mmap（）映射内存需要记录物理内存加交换内存地址，所有物理内存加交换内存限制了malloc实际分配。
比如32位情况下，最新版本的linux的映射区在用户空间区的3G位置，而映射区向下生长，所以理想情况下大概能有2.9GB（除去开始地址128M）,
如果你的物理内存加交换区只有2G，malloc一次申请最多1.8G左右，如果你的物理内存加交换区大于4G，那么最多能有2.9G或者2.8G左右。网上能找到测试代码的。


每个程序的虚拟内存空间都是4G




## 内存对齐
什么是内存对齐?有两种解释：
1. 数据结构所占字节数是某个数（通常它为4，8或者32）的倍数。

编译器为了让程序跑得更快，减少CPU读取数据的指令周期，对数据的存储进行了优化，

	#pragma pack (n)，gcc编译器将按照n个字节对齐。
	#pragma pack ()，取消自定义字节对齐方式。

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐位数），对齐位数跟处理器位数和编译器都有关。
VS, VC等编译器默认是 `#pragma pack(8)`
gcc中默认 `#pragma pack(4)`，并且gcc只支持1,2,4对齐。
可以通过预编译命令 `#pragma pack(n)`，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值 `#pragma pack(n)` 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。


2. 存放数据的首地址是某个数（通常它为4，8或者32）的倍数。

因为我们如果用到了simd256技术的话，simd一种单指令多数据的数据，而256就是指同时操作256bit的数据，而256bit=32byte。因此simd256技术要求所操作的数据的首地址是内存对齐32字节。

```C++
#include<iostream>
 
void* aligned_malloc(size_t size, int alignment)
{
	// 分配足够的内存, 这里的算法很经典, 早期的STL中使用的就是这个算法  
 
	// 首先是维护FreeBlock指针占用的内存大小  
	const int pointerSize = sizeof(void*);
 
	// alignment - 1 + pointerSize这个是FreeBlock内存对齐需要的内存大小  
	// 前面的例子sizeof(T) = 20, __alignof(T) = 16,  
	// g_MaxNumberOfObjectsInPool = 1000  
	// 那么调用本函数就是alignedMalloc(1000 * 20, 16)  
	// 那么alignment - 1 + pointSize = 19  
	const int requestedSize = size + alignment - 1 + pointerSize;
 
	// 分配的实际大小就是20000 + 19 = 20019  
	void* raw = malloc(requestedSize);
 
	// 这里实Pool真正为对象实例分配的内存地址  
	uintptr_t start = (uintptr_t)raw + pointerSize;
	// 向上舍入操作  
	// 解释一下, __ALIGN - 1指明的是实际内存对齐的粒度  
	// 例如__ALIGN = 8时, 我们只需要7就可以实际表示8个数(0~7)  
	// 那么~(__ALIGN - 1)就是进行舍入的粒度  
	// 我们将(bytes) + __ALIGN-1)就是先进行进位, 然后截断  
	// 这就保证了我是向上舍入的  
	// 例如byte = 100, __ALIGN = 8的情况  
	// ~(__ALIGN - 1) = (1 000)B  
	// ((bytes) + __ALIGN-1) = (1 101 011)B  
	// (((bytes) + __ALIGN-1) & ~(__ALIGN - 1)) = (1 101 000 )B = (104)D  
	// 104 / 8 = 13, 这就实现了向上舍入  
	// 对于byte刚好满足内存对齐的情况下, 结果保持byte大小不变  
	// 记得《Hacker's Delight》上面有相关的计算  
	// 这个表达式与下面给出的等价  
	// ((((bytes) + _ALIGN - 1) * _ALIGN) / _ALIGN)  
	// 但是SGI STL使用的方法效率非常高   
	void* aligned = (void*)((start + alignment - 1) & ~(alignment - 1));
 
	// 这里维护一个指向malloc()真正分配的内存  
	*(void**)((uintptr_t)aligned - pointerSize) = raw;
 
	// 返回实例对象真正的地址  
	return aligned;
}
 
 
// 这里是内部维护的内存情况  
//                   这里满足内存对齐要求  
//                             |  
// ----------------------------------------------------------------------  
// | 内存对齐填充 | 维护的指针 | 对象1 | 对象2 | 对象3 | ...... | 对象n |  
// ----------------------------------------------------------------------  
// ^                     | 指向malloc()分配的地址起点  
// |                     |  
// -----------------------  
template<typename T>
void aligned_free(T * aligned_ptr)
{
	if (aligned_ptr)
	{
		free(((T**)aligned_ptr)[-1]);
	}
}
 
bool isAligned(void* data, int alignment)
{
	// 又是一个经典算法, 参见<Hacker's Delight>  
	return ((uintptr_t)data & (alignment - 1)) == 0;
}
 
void main() {
	int totalsize = 10;
	int* data = (int*)aligned_malloc(sizeof(int)*totalsize, 32);
 
	if (isAligned(data, 32)) {
		std::cout << "isAligned\n";
	}
	memset(data, 0, sizeof(int)*totalsize);
	data[5] = 1;
 
	for (int i = 0; i < totalsize; i++) {
		std::cout << data[i] << " ";
	}
	std::cout << "\n";
	aligned_free<int>(data);
	std::cout << "aligned_free\n";
	while(1){}
}
```




