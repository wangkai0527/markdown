[TOC]

#数组
***

##数组定义
一组变量的集合，连续保存了多个数据的**引用类型的对象**
***

##数组分类
+ 索引数组
+ 关联数组（哈希数组）
+ 二维数组
***

##创建数组方式
1. 创建空数组：var 数组名=[];
    暂时不知道数据内容的时候，先创建，再追加
2. 创建数组的同时就初始化数组的内容
    var 数组名=[值1,值2,...];
3. 创建指定元素个数的数组
    var 数组名=new Array(n)
    创建一个数组对象，同时初始化了n个空元素
4. 创建数组的同时直接初始化数组内容
    var 数组名=new Array(值1,值2,....);  

3,4方法不常用，因为有歧义
比如：var arr=new Array(5);
可以解释为初始化了5个空元素，也可以解释为初始化了1个元素值为5
***

##索引数组
+ 如何取数组中的元素值： 变量=数组名[下标];
+ 如何进行赋值操作： 数组名[下标]=新值
+ 如何获取数组的长度：arr.length属性
+ 获得数组中最后一个元素固定写法： arr[arr.length-1]
+ 数组的越界问题：**数组的下标如果越界了，那么arr[越界下标值],不会报错，返回undefined**

1. 什么是对象：
  js中的对象。指内存中集中保存一组相关数据和功能的整体
  对象都是new操作符创建的！
  new 专门用于在内存中开辟一个空间，来保存数据和功能，返回的是**存储空间的地址**
2. 数组是个对象，数组名作为一个变量或者参数传递的时候，都是将地址复制一份给了对方
    后果，如果对方修改了数组内容，则原数组对象也会被改变

3. null：null专门表示一个变量不在指向任何对象的地址
    null和undefined的区别
    他俩都是原始数据类型，保存在**栈**中的变量
    不同：undefined表示变量声明过，但是没有赋值，是所有未赋值的变量的默认值
    null， 表示一个变量将来可能指向一个对象，但是目前来说什么也没有指向。
        一般主要用于主动的释放指向对象的引用！
    var arr=[1,2,3];
    arr=null;

###垃圾回收器
+ 伴随主程序存在的，每个对象当前的引用次数=0。
+ 垃圾回收器自动的释放内存空间
+ 强烈建议：在使用完较大的对象后，主动赋值null，总是一个好习惯!

***

##关联数组
###关联数组（hash数组）定义
可以自定义元素的下标名称的数组

###如何创建关联数组
1. 先创建空数组，再追加自定义下标的元素  
    * 关联数组的length属性失效
    * 关联数组的自定义下标不能重复声明
    * 关联数组中保存的都是多个 key/value 键值对儿
    * 查找起来非常的快，和元素个数无关！
2. 创建数组的同时，直接初始化元素内容

``` javascript
    var student=[];
    student["sname"]="张三";
    student["age"]=18;
    student["gender"]="男";

    var student1={"sname":"张三","age":18,"gender":"男"};
    var student2={sname:"张三",age:18,gender:"男"};
    console.log(student);
    console.log(student1);
    console.log(student2);
```

>{sname: "张三", age: 18, gender: "男"}
{sname: "张三", age: 18, gender: "男"}
{sname: "张三", age: 18, gender: "男"}


###如何遍历关联数组？
``` javascript
    for(var key in arr){
        //依次取出arr中的key，存在一个变量中
        arr[key];//获得当前key对应的value值
    }
```

***

##二维数组
###二维数组（2d数组）
数组中的某个元素，又指向了另一个子数组对象

###使用场景
 1. 存储横行数列二维数据时，比如 2048游戏
 2. 存储上下级包含关系的数据 比如：2级联动下拉列表

###如何创建
  1. 先创建普通的空数组，再逐个追加元素（子数组）
  2. 创建的同时，直接初始化子数组

###如何获得二维数组中的指定元素值
arr[row][col]

###如何遍历二维数组
外层循环遍历行，内层循环遍历列

```javascript
for(var row=0;row<arr.length;row++){
    for(var col=0;col<arr[row].length;col++){
        arr[row][col];//当前元素
    }
}
```

二维数组中
row  行下标  ***不可越界***   
报错undefined[col]
col  列下标  可以越界

###2048游戏
``` javascript
    var data=[
    // col：0 1 2 3
        [2,4,2,4],//row:0
        [4,2,4,2],//row:1
        [2,4,2,2],//row:2
        [4,2,4,2] //row:3
    ];
//    2048的游戏结束判断逻辑
//    1. 必须格子全部满员（说明data[row][col]!=0）
//    2. 满员后，且每次移动（上下左右）都不能合并了
    function isFull(){
    //    遍历data中每个元素
        for(var row=0;row<data.length;row++){
            for(var col=0;col<data[row].length;col++){
            //    如果当前元素 == 0
                if(data[row][col]==0){
                    //返回false，并退出函数
                    return false;
                }
            }
        }
        return true;
    }
    function isGameOver(){
        //1. 判断格子满不满
        if(!isFull()){// 如果不满
            return false;
        }else{
        //2. 如果满了，那么需要验证每个元素是否能与相邻的元素进行合并
            for(var row=0;row<data.length;row++){
                for(var col=0;col<data[row].length;col++){
                //如果不是最右侧列且当前元素值==右侧元素值，那么游戏不能结束
                    if(col!=data[row].length-1
                        &&data[row][col]==data[row][col+1]){
                        return false;
                    }
                //如果不是最后一行且当前元素值==下方元素值，那么游戏不能结束
                    if(row!=data.length-1
                        &&data[row][col]==data[row+1][col]){
                        return false;
                    }
                }
            }// 遍历结束后，说明格子满了，且没有能合并的元素了，return true
            return true;
        }
    }
    console.log(isGameOver());
```

***

